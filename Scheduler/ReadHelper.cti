// $Id$
//
// Copyright (C) 2006 

// Definition of inline template functions

#include "ReadHelper.ih"

// Custom includes
#include "Utils/Exception.hh"

#define prefix_ inline
///////////////////////////////cti.p///////////////////////////////////////

template <class Handle>
prefix_ typename senf::ReadHelper<Handle>::ptr
senf::ReadHelper<Handle>::dispatch(Handle handle, std::string::size_type maxSize,
                                          Callback callback)
{
    return ptr(new ReadHelper(handle, maxSize, 0, callback));
}

template <class Handle>
template <class Predicate>
prefix_ typename senf::ReadHelper<Handle>::ptr
senf::ReadHelper<Handle>::dispatch(Handle handle, std::string::size_type maxSize,
                                          Predicate predicate, Callback callback)
{
    return ptr(new ReadHelper(handle, maxSize, 
			      new typename InternalPredicate::template Dispatcher<Predicate>(predicate),
			      callback));
}

template <class Handle>
prefix_ Handle senf::ReadHelper<Handle>::handle()
    const
{
    return handle_;
}

template <class Handle>
prefix_ unsigned senf::ReadHelper<Handle>::maxSize()
    const
{
    return maxSize_;
}

template <class Handle>
prefix_ std::string const & senf::ReadHelper<Handle>::data()
    const
{
    return data_;
}

template <class Handle>
prefix_ std::string const & senf::ReadHelper<Handle>::tail()
    const
{
    return tail_;
}

template <class Handle>
prefix_ bool senf::ReadHelper<Handle>::complete()
    const
{
    return complete_;
}

template <class Handle>
prefix_ bool senf::ReadHelper<Handle>::error()
    const
{
    return errno_ != 0;
}

template <class Handle>
prefix_ void senf::ReadHelper<Handle>::throw_error()
    const
{
    if (errno_ != 0) throw SystemException(errno_);
}

///////////////////////////////cti.e///////////////////////////////////////
#undef prefix_


// Local Variables:
// mode: c++
// End:
