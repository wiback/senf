// $Id$
//
// Copyright (C) 2013
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

/** \file
    \brief QueueReadWritePolicy inline non-template implementation */

#include "QueueReadWritePolicy.ih"

// Custom includes
#include <sys/types.h>
#include <sys/socket.h>

#define prefix_ inline
//-/////////////////////////////////////////////////////////////////////////////////////////////////

prefix_ senf::detail::QueueInfo * senf::detail::QueuePolicyBase::qinfo(FileHandle & handle)
{
    SENF_ASSERT( extraPtr(handle), "invalid queue file handle (no QueueInfo found)");
    return static_cast<detail::QueueInfo *>(extraPtr(handle));
}

prefix_ void senf::detail::QueueInfo::inc(char * & ptr, Queue const & q)
{
    ptr += frameSize;
    if (ptr == q.end)
        ptr = q.begin;
}

///////////////////////////////////////////////////////////////////////////
// senf::SocketQueueBuffer

prefix_ senf::SocketQueueBuffer::SocketQueueBuffer()
    : b_ (0), e_ (0)
{}

prefix_ senf::SocketQueueBuffer::SocketQueueBuffer(char * b, char * e)
    : b_ (b), e_ (e)
{}

prefix_ struct ::tpacket2_hdr & senf::SocketQueueBuffer::hdr()
{
    return * reinterpret_cast<struct ::tpacket2_hdr *>(b_);
}

prefix_ struct ::tpacket2_hdr const & senf::SocketQueueBuffer::hdr()
    const
{
    return * reinterpret_cast<struct ::tpacket2_hdr const *>(b_);
}

prefix_ senf::SocketQueueBuffer::iterator senf::SocketQueueBuffer::begin()
{ return b_ + hdr().tp_mac; }

prefix_ senf::SocketQueueBuffer::iterator senf::SocketQueueBuffer::end()
{ return begin() + hdr().tp_len; }

prefix_ senf::SocketQueueBuffer::const_iterator senf::SocketQueueBuffer::begin()
    const
{ return b_ + hdr().tp_mac; }

prefix_ senf::SocketQueueBuffer::const_iterator senf::SocketQueueBuffer::end()
    const
{ return begin() + hdr().tp_len; }

prefix_ senf::SocketQueueBuffer::size_type senf::SocketQueueBuffer::size()
    const
{ return hdr().tp_len; }

prefix_ bool senf::SocketQueueBuffer::empty()
    const
{ return hdr().tp_len == 0; }

prefix_ senf::SocketQueueBuffer::iterator senf::SocketQueueBuffer::frameBegin()
{ return begin(); }

prefix_ senf::SocketQueueBuffer::iterator senf::SocketQueueBuffer::frameEnd()
{ return e_; }

prefix_ size_type senf::SocketQueueBuffer::frameSize()
    const
{
    return frameEnd() - frameBegin();
}

prefix_ senf::SocketQueueBuffer::const_iterator senf::SocketQueueBuffer::frameBegin()
    const
{ return begin(); }

prefix_ senf::SocketQueueBuffer::const_iterator senf::SocketQueueBuffer::frameEnd()
    const
{ return e_; }

prefix_ senf::SocketQueueBuffer::iterator senf::SocketQueueBuffer::spaceBegin()
{ return b_
        + offsetof(struct ::tpacket2_hdr, tp_status)
        + sizeof(::tpacket2_hdr::tp_status); }

prefix_ senf::SocketQueueBuffer::iterator senf::SocketQueueBuffer::spaceEnd()
{ return e_; }

prefix_ size_type senf::SocketQueueBuffer::spaceSize()
    const
{
    return spaceEnd() - spaceBegin();
}

prefix_ senf::SocketQueueBuffer::const_iterator senf::SocketQueueBuffer::spaceBegin()
    const
{ return b_
        + offsetof(struct ::tpacket2_hdr, tp_status)
        + sizeof(::tpacket2_hdr::tp_status); }

prefix_ senf::SocketQueueBuffer::const_iterator senf::SocketQueueBuffer::spaceEnd()
    const
{ return e_; }

prefix_ senf::ClockService::clock_type senf::SocketQueueBuffer::timestamp()
    const
{
    return ClockService::from_time_t(hdr().tp_sec) + ClockService::nanoseconds(hdr().tp_nsec);
}

prefix_ senf::LLSocketAddress senf::SocketQueueBuffer::address()
    const
{
    SENF_ASSERT( hdr().tp_mac > TPACKET_ALIGN(sizeof(struct ::tpacket2_hdr)),
                 "frame has no address field" );
    senf::LLSocketAddress res;
    ::memcpy(res.sockaddr_p(),
             reinterpret_cast<struct ::sockaddr_ll *>(
                 b_ + TPACKET_ALIGN(sizeof(struct ::tpacket2_hdr))),
             sizeof(struct  ::sockaddr_ll));
    return res;
}

prefix_ void senf::SocketQueueBuffer::resize(size_type sz)
{
    SENF_ASSERT( frameBegin() + sz <= frameEnd(),
                 "frame size exceeded" );
    hdr().tp_len = sz;
}

///////////////////////////////////////////////////////////////////////////
// senf::QueueReadPolicy

prefix_ boost::optional<senf::QueueReadPolicy::Buffer>
senf::QueueReadPolicy::dequeue(FileHandle & handle)
{
    detail::QueueInfo & qi (* qinfo(handle));
    struct ::tpacket2_hdr & pk (* reinterpret_cast<struct ::tpacket2_hdr *>(qi.rx.head));
    for (;;) {
        if ((qi.rx.idle || qi.rx.head != qi.rx.tail) && pk.tp_status != TP_STATUS_KERNEL) {
            Buffer bf (qi.rx.head, qi.rx.head + qi.frameSize);
            struct ::sockaddr_ll & sa (
                * reinterpret_cast<struct ::sockaddr_ll *>(
                    qi.rx.head + TPACKET_ALIGN(sizeof(struct ::tpacket2_hdr))));
            qi.inc(qi.rx.head, qi.rx);
            if (sa.sll_pkttype >= PACKET_OUTGOING) {
                if (qi.rx.idle) {
                    pk.tp_status = TP_STATUS_KERNEL;
                    qi.rx.tail = qi.rx.head;
                }
                continue;
            }
            qi.rx.idle = false;
            return bf;
        }
        return boost::none;
    }
}

prefix_ void senf::QueueReadPolicy::release(FileHandle & handle)
{
    detail::QueueInfo & qi (* qinfo(handle));
    while (! qi.rx.idle || qi.rx.tail != qi.rx.head) {
        struct ::tpacket2_hdr & pk (* reinterpret_cast<struct ::tpacket2_hdr*>(qi.rx.tail));
        pk.tp_status = TP_STATUS_KERNEL;
        qi.inc(qi.rx.tail, qi.rx);
        // We set qi.rx.idle prematurely but this is safe: when the while loop is done,
        // the queue is indeed idle. After the first loop iteration, it is impossible for
        // the queue to be still completely filled (that is head == tail) so the while
        // condition above is now correkt with idle = true
        qi.rx.idle = true;
    }
}

prefix_ unsigned senf::QueueReadPolicy::read(FileHandle & handle, char * buffer, unsigned size)
{
    SENF_ASSERT( qinfo(handle)->rx.idle,
                 "Inconsistent mixing of read() and dequeue() on mmap socket" );
    bool blocking (false);
    for (;;) {
        boost::optional<Buffer> buf (dequeue(handle));
        if (! buf) {
            if (blocking || handle.blocking()) {
                blocking = true;
                handle.waitReadable();
                continue;
            }
            return 0;
        }
        if (unsigned(buf->size()) < size)
            size = buf->size();
        ::memcpy(buffer, buf->begin(), size);
        release(handle);
        return size;
    }
}

///////////////////////////////////////////////////////////////////////////
// senf::QueueWritePolicy

prefix_ boost::optional<senf::QueueWritePolicy::Buffer>
senf::QueueWritePolicy::enqueue(FileHandle & handle)
{
    detail::QueueInfo & qi (* qinfo(handle));
    struct ::tpacket2_hdr & pk (* reinterpret_cast<struct ::tpacket2_hdr*>(qi.tx.head));
    if ((qi.tx.idle || qi.tx.head != qi.tx.tail) && pk.tp_status == TP_STATUS_AVAILABLE) {
        pk.tp_len = 0;
        pk.tp_mac = TPacketHdrOffset;
        Buffer bf (qi.tx.head, qi.tx.head + qi.frameSize);
        qi.inc(qi.tx.head, qi.tx);
        qi.tx.idle = false;
        return bf;
    }
    return boost::none;
}

prefix_ void senf::QueueWritePolicy::send(FileHandle & handle)
{
    detail::QueueInfo & qi (* qinfo(handle));
    while (! qi.tx.idle || qi.tx.tail != qi.tx.head) {
        struct ::tpacket2_hdr & pk (* reinterpret_cast<struct ::tpacket2_hdr*>(qi.tx.tail));
#ifdef SENF_DEBUG
        SENF_ASSERT(pk.tp_len, "missing call to enqueue()");
#endif
        pk.tp_status = TP_STATUS_SEND_REQUEST;
        qi.inc(qi.tx.tail, qi.tx);
        // We set qi.rx.idle prematurely but this is safe: when the while loop is done,
        // the queue is indeed idle. After the first loop iteration, it is impossible for
        // the queue to be still completely filled (that is head == tail) so the while
        // condition above is now correkt with idle = true
        qi.tx.idle = true;
    }
    for (;;) {
        if (::send(handle.fd(), NULL, 0, 0) < 0) {
            if (errno == EINTR || errno == EAGAIN)
                continue;
            SENF_THROW_SYSTEM_EXCEPTION("::send()");
        }
        break;
    }
}

prefix_ unsigned senf::QueueWritePolicy::write(FileHandle & handle, char const * buffer,
                                               unsigned size)
{
    SENF_ASSERT( qinfo(handle)->tx.idle,
                 "Inconsistent mixing of write() and enqueue() on mmap socket" );
    for (bool repeat (true);; repeat = false) {
        boost::optional<Buffer> buf (enqueue(handle));
        if (! buf) {
            if (repeat && handle.blocking()) {
                handle.waitWriteable();
                continue;
            }
            return 0;
        }
        if (unsigned(buf->size()) < size)
            size = buf->size();
        buf->resize(size);
        ::memcpy(buf->begin(), buffer, size);
        send(handle);
        return size;
    }
}
g
//-/////////////////////////////////////////////////////////////////////////////////////////////////
#undef prefix_


// Local Variables:
// mode: c++
// fill-column: 100
// comment-column: 40
// c-file-style: "senf"
// indent-tabs-mode: nil
// ispell-local-dictionary: "american"
// compile-command: "scons -u test"
// End:
