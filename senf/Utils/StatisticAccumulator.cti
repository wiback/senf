// $Id$
//
// Copyright (C) 2010
// Fraunhofer Institute for Open Communication Systems (FOKUS)
//
// The contents of this file are subject to the Fraunhofer FOKUS Public License
// Version 1.0 (the "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at 
// http://senf.fit.fraunhofer.de/license.html
//
// The Fraunhofer FOKUS Public License Version 1.0 is based on, 
// but modifies the Mozilla Public License Version 1.1.
// See the full license text for the amendments.
//
// Software distributed under the License is distributed on an "AS IS" basis, 
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License 
// for the specific language governing rights and limitations under the License.
//
// The Original Code is Fraunhofer FOKUS code.
//
// The Initial Developer of the Original Code is Fraunhofer-Gesellschaft e.V. 
// (registered association), Hansastra√üe 27 c, 80686 Munich, Germany.
// All Rights Reserved.
//
// Contributor(s):
//   Mathias Kretschmer <mathias.kretschmer@fokus.fraunhofer.de>
//   Jens Moedeker <jens.moedeker@fokus.fraunhofer.de>

/** \file
    \brief StatisticAccumulator inline template implementation */

// Custom includes

#define prefix_ inline
///////////////////////////////cti.p///////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// senf::StatisticAccumulator<T>

template <class T>
prefix_ T senf::StatisticAccumulator<T>::min()
    const
{
    return min_;
}

template <class T>
prefix_ T senf::StatisticAccumulator<T>::max()
    const
{
    return max_;
}

template <class T>
prefix_ T senf::StatisticAccumulator<T>::sum()
    const
{
    return sum_;
}

template <class T>
prefix_ T senf::StatisticAccumulator<T>::sum2()
    const
{
    return sum_squared_;
}

template <class T>
prefix_ float senf::StatisticAccumulator<T>::avg()
    const
{
    return cnt_ == 0 ? NAN : float(sum_) / float(cnt_);
}

template <class T>
prefix_ float senf::StatisticAccumulator<T>::rms()
    const
{
    return cnt_ == 0 ? NAN : sqrtf(float(sum_squared_) / float(cnt_));
}

template <class T>
prefix_ unsigned senf::StatisticAccumulator<T>::count()
    const
{
    return cnt_;
}

template <class T>
prefix_ void senf::StatisticAccumulator<T>::accumulate(T const & value)
{
    sum_ += value;
    sum_squared_ += value * value;
    cnt_++;
    min_ = std::min(min_, value);
    max_ = std::max(max_, value);
}

template <class T>
prefix_ senf::StatisticAccumulator<T>::operator bool()
    const
{
    return cnt_ > 0;
}

//
// EWMA
//

template <class T>
prefix_ void senf::StatisticsEWMA<T>::accumulate(T const & value)
{
    ewma_ = (ewma_ * (1.0f - alpha_)) + (value * alpha_); 
    cnt_++;
}

template <class T>
prefix_ void senf::StatisticsEWMA<T>::accumulateWithLoss(T const & value, unsigned numLost)
{
    // we substitute the lost data with a avg of the last ewma and the new data
    T avg ((ewma_ + value) * 0.5f);

    // account for lost data with avg
    for (unsigned n = 0; n < numLost; n++) {
        accumulate(avg);
    }

    // feed in new value
    accumulate(value);
}

template <class T>
prefix_ senf::StatisticsEWMA<T>::operator bool()
    const
{
    return cnt_ > 0;
}

template <class T>
prefix_ bool senf::StatisticsEWMA<T>::operator<(senf::StatisticsEWMA<T> const & other)
    const
{
    return ewma_ < other.ewma_;
}

template <class T>
prefix_ unsigned senf::StatisticsEWMA<T>::count()
    const
{
    return cnt_;
}

template <class T>
prefix_ T const & senf::StatisticsEWMA<T>::ewma()
    const
{
    return ewma_;
}

template <class T>
prefix_ float const & senf::StatisticsEWMA<T>::alpha()
    const
{
    return alpha_;
}


///////////////////////////////cti.e///////////////////////////////////////
#undef prefix_


// Local Variables:
// mode: c++
// fill-column: 100
// comment-column: 40
// c-file-style: "senf"
// indent-tabs-mode: nil
// ispell-local-dictionary: "american"
// compile-command: "scons -U"
// End:
