// $Id$
//
// Copyright (C) 2010
// Fraunhofer Institute for Open Communication Systems (FOKUS)
// Competence Center NETwork research (NET), St. Augustin, GERMANY
//     Mathias Kretschmer <mtk@berlios.de>
//     Jens Moedeker <jens.moedeker@fokus.fraunhofer.de>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

/** \file
 \brief TimerEventProxy public header */

#define prefix_ 

template<class T>
prefix_ senf::scheduler::TimerEventProxy<T>::TimerEventProxy() 
    : timer("TimerEventProxy", senf::membind(&TimerEventProxy<T>::timerEvent, this), 0, false), 
      entrySetById(entrySet.template get<Id> ()),
      entrySetByTimeout(entrySet.template get<Timeout> ())
{ }

template<class T>
prefix_ senf::scheduler::TimerEventProxy<T>::TimerEventProxy( std::string const & name,
        senf::console::DirectoryNode & node) 
    : timer("TimerEventProxy", senf::membind(&TimerEventProxy<T>::timerEvent, this), 0, false),
      entrySetById(entrySet.template get<Id> ()),
      entrySetByTimeout(entrySet.template get<Timeout> ())
{
    node.add(name, senf::console::factory::Command(
            &TimerEventProxy<T>::list, this) .doc("List active Timers"));
}

template<class T>
prefix_ void senf::scheduler::TimerEventProxy<T>::timerEvent() {

    senf::ClockService::clock_type actual = senf::ClockService::now();
    typename EntrySetByTimeout_t::iterator it;

    // execute the timer callbacks first

    it = entrySetByTimeout.begin();
    while (it != entrySetByTimeout.end() && it->timeout <= actual) {
        Entry item (*it);
        // remove due entry from set
        entrySetByTimeout.erase(it);
        // call callback
        item.cb(actual, item.id);

        it = entrySetByTimeout.begin();
    }

    if (entrySet.size() > 0) {
        timer.timeout(entrySetByTimeout.begin()->timeout);
    }
}

template<class IdType>
prefix_ void senf::scheduler::TimerEventProxy<IdType>::add(
        senf::ClockService::clock_type timeout, IdType const & id, Callback cb)
{
    // insert new entry
    entrySetByTimeout.insert( Entry(timeout, id, cb));

    // the scheduler time to the first earliest timeout (ordered index)
    timer.timeout( entrySetByTimeout.begin()->timeout);
}

template<class IdType>
prefix_ bool senf::scheduler::TimerEventProxy<IdType>::remove(IdType const & id)
{
    return entrySetById.erase( id) > 0;
}

template<class IdType>
prefix_ std::vector<std::pair<senf::ClockService::clock_type, IdType> > senf::scheduler::TimerEventProxy<IdType>::list()
{
    std::vector<std::pair<senf::ClockService::clock_type, IdType> > tmp;

    typename EntrySetByTimeout_t::iterator it;
    for (it = entrySetByTimeout.begin(); it != entrySetByTimeout.end(); ++it) {
        tmp.push_back(std::make_pair<senf::ClockService::clock_type, IdType>( it->timeout, it->id));
    }

    return tmp;
}

#undef prefix_

