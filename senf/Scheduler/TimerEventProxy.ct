// $Id$
//
// Copyright (C) 2010
// Fraunhofer Institute for Open Communication Systems (FOKUS)
//
// The contents of this file are subject to the Fraunhofer FOKUS Public License
// Version 1.0 (the "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at 
// http://senf.berlios.de/license.html
//
// The Fraunhofer FOKUS Public License Version 1.0 is based on, 
// but modifies the Mozilla Public License Version 1.1.
// See the full license text for the amendments.
//
// Software distributed under the License is distributed on an "AS IS" basis, 
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License 
// for the specific language governing rights and limitations under the License.
//
// The Original Code is Fraunhofer FOKUS code.
//
// The Initial Developer of the Original Code is Fraunhofer-Gesellschaft e.V. 
// (registered association), Hansastra√üe 27 c, 80686 Munich, Germany.
// All Rights Reserved.
//
// Contributor(s):
//   Mathias Kretschmer <mtk@berlios.de>
//   Jens Moedeker <jmo@berlios.de>

/** \file
    \brief TimerEventProxy non-inline template implementation */

// Custom includes
#include <senf/Utils/membind.hh>

#define prefix_
//-/////////////////////////////////////////////////////////////////////////////////////////////////

template<typename IdType>
prefix_ senf::scheduler::TimerEventProxy<IdType>::TimerEventProxy(std::string const & description)
    : entrySetById( entrySet.template get<Id>()),
      entrySetByTimeout( entrySet.template get<Timeout> ()),
      timer( "TimerEventProxy " + description,
              membind(&TimerEventProxy<IdType>::timerEvent, this), ClockService::clock_type(0), false)
{ }

template<typename IdType>
prefix_ void senf::scheduler::TimerEventProxy<IdType>::timerEvent()
{
    ClockService::clock_type now = senf::scheduler::now();
    typename EntrySetByTimeout_t::iterator it = entrySetByTimeout.begin();
    while (it != entrySetByTimeout.end() && it->timeout <= now) {
        Entry item (*it);
        // remove due entry from set
        entrySetByTimeout.erase(it);
        // call callback
        item.cb(now, item.id);
        it = entrySetByTimeout.begin();
    }
    if (entrySet.size() > 0)
        timer.timeout(entrySetByTimeout.begin()->timeout);
}

template<typename IdType>
prefix_ void senf::scheduler::TimerEventProxy<IdType>::add(
        ClockService::clock_type timeout, IdType const & id, Callback cb)
{
    // insert new entry or replace the timeout of an entry already indexed
    typename EntrySetById_t::iterator i = entrySetById.find(id);
    if (i == entrySetById.end())
        entrySetByTimeout.insert( Entry(timeout, id, cb));
    else {
        Entry tmp = *i;
        tmp.timeout = timeout;
        entrySetById.replace(i,tmp);
    }
    // the scheduler time to the first earliest timeout (ordered index)
    timer.timeout( entrySetByTimeout.begin()->timeout);
}

template<typename IdType>
prefix_ bool senf::scheduler::TimerEventProxy<IdType>::remove(IdType const & id)
{
    bool removed (entrySetById.erase( id) > 0);
    if (entrySet.size() > 0)
        timer.timeout(entrySetByTimeout.begin()->timeout);
    else
        timer.disable();
    return removed;
}

template<typename IdType>
prefix_ senf::ClockService::clock_type senf::scheduler::TimerEventProxy<IdType>::timeout(IdType const & id)
    const
{
    typename EntrySetById_t::const_iterator i ( entrySetById.find( id));
    return i == entrySetById.end() ? ClockService::clock_type(0) : i->timeout;
}


template<typename IdType>
prefix_ std::vector<std::pair<senf::ClockService::clock_type, IdType> > senf::scheduler::TimerEventProxy<IdType>::list()
    const
{
    std::vector<std::pair<ClockService::clock_type, IdType> > tmp;

    typename EntrySetByTimeout_t::const_iterator it;
    for (it = entrySetByTimeout.begin(); it != entrySetByTimeout.end(); ++it) {
        tmp.push_back(std::make_pair( it->timeout, it->id));
    }
    return tmp;
}

template<typename IdType>
prefix_ unsigned senf::scheduler::TimerEventProxy<IdType>::numEvents()
  const
{
    return entrySetByTimeout.size();
}

template<typename IdType>
prefix_ void senf::scheduler::TimerEventProxy<IdType>::clear()
{
    entrySetByTimeout.clear();
}

//-/////////////////////////////////////////////////////////////////////////////////////////////////
#undef prefix_


// Local Variables:
// mode: c++
// fill-column: 100
// c-file-style: "senf"
// indent-tabs-mode: nil
// ispell-local-dictionary: "american"
// compile-command: "scons -u test"
// comment-column: 40
// End:


