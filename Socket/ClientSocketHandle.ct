// $Id$
//
// Copyright (C) 2006
// Fraunhofer Institut fuer offene Kommunikationssysteme (FOKUS)
// Kompetenzzentrum fuer Satelitenkommunikation (SatCom)
//     Stefan Bund <stefan.bund@fokus.fraunhofer.de>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

/** \file
    \brief ClientSocketHandle non-inline template implementation
 */

#include "ClientSocketHandle.ih"

// Custom includes
#include <algorithm>
#include "Utils/Buffer.hh"

#define prefix_
///////////////////////////////ct.p////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// senf::detail::ReadRange<Handle,ForwardWritableRange,IsContiguous>

// senf::detail::ReadRange<Handle,ForwardWritableRange,IsContiguous>::read

template <class Handle, class ForwardWritableRange, bool IsContiguous>
prefix_ typename boost::range_iterator<ForwardWritableRange>::type
senf::detail::ReadRange<Handle,ForwardWritableRange,IsContiguous>::
read(Handle & handle, ForwardWritableRange & range)
{
    typename boost::range_size<ForwardWritableRange>::type nread (boost::size(range));
    SENF_SCOPED_BUFFER(char, buffer, nread);
    return std::copy(buffer, handle.read(buffer,buffer+nread), boost::begin(range));
}

// senf::detail::ReadRange<Handle,ForwardWritableRange,IsContiguous>::readfrom

template <class Handle, class ForwardWritableRange, bool IsContiguous>
prefix_ typename boost::range_iterator<ForwardWritableRange>::type
senf::detail::ReadRange<Handle,ForwardWritableRange,IsContiguous>::
readfrom(Handle & handle, ForwardWritableRange & range, typename Handle::Address & addr)
{
    typename boost::range_size<ForwardWritableRange>::type nread (boost::size(range));
    SENF_SCOPED_BUFFER(char, buffer, nread);
    return std::copy(buffer, handle.readfrom(buffer,buffer+nread,addr), boost::begin(range));
}

///////////////////////////////////////////////////////////////////////////
// senf::ClientSocketHandle<Policy>

////////////////////////////////////////
// reading and writing

// senf::ClientSocketHandle<Policy>::read

template <class Policy>
prefix_ std::string senf::ClientSocketHandle<Policy>::read(unsigned limit)
{
    std::string rv;
    this->read(rv,limit);
    return rv;
}

template <class Policy>
template <class Sequence>
prefix_ void senf::ClientSocketHandle<Policy>::read(Sequence & container, unsigned limit)
{
    unsigned nread (available());
    if (limit>0 && nread>limit)
        nread = limit;
    container.resize(nread);
    container.erase(read( std::make_pair(container.begin(), container.end()) ), 
                    container.end());
}

// senf::ClientSocketHandle<Policy>::readfrom

template <class Policy>
prefix_ std::pair<std::string, typename Policy::AddressingPolicy::Address>
senf::ClientSocketHandle<Policy>::readfrom(unsigned limit)
{
    std::string rv;
    typename Policy::AddressingPolicy::Address addr;
    this->readfrom(rv,addr,limit);
    return std::make_pair(rv,addr);
}

template <class Policy>
template <class Sequence>
prefix_ void senf::ClientSocketHandle<Policy>::readfrom(Sequence & container, Address & from,
                                                        unsigned limit)
{
    unsigned nread (available());
    if (limit>0 && nread>limit)
        nread = limit;
    container.resize(nread);
    container.erase(readfrom( std::make_pair(container.begin(), container.end()), from ), 
                    container.end());
}

// senf::ClientSocketHandle<Policy>::write

template <class Policy>
prefix_ unsigned senf::ClientSocketHandle<Policy>::write(std::string const & data)
{
    unsigned written = this->write(data.data(),data.size());
    if (written == 0)
        throw SystemException(EPIPE);
    // This implementation ensures, we only call blocking() when
    // necessary (since it incurs a system call overhead ...)
    if (written < data.size() && this->blocking())
        // We need to enforce in the WritePolicy implementation, that
        // DatagramFramingPolicy sockets will ALWAYS either write the
        // complete datagram or nothing at all
        while (written < data.size()) {
            unsigned n = this->write(data.data()+written,data.size()-written);
            if (n == 0)
                throw SystemException(EPIPE);
            written += n;
        }
    return written;
}

////////////////////////////////////////
// private members

// senf::ClientSocketHandle<Policy>::available

template <class Policy>
prefix_ unsigned senf::ClientSocketHandle<Policy>::available()
{
    unsigned nread = this->protocol().available();
    if (nread == 0 && this->blocking()) {
        // We have to block explicitly here so we can return the
        // number of bytes available explicitly. If no more date can
        // be expected to arive (i.e. the other end has closed the
        // connection), the socket will always be in the readable
        // state. This is the only case when available() will return
        // 0.
        this->waitReadable();
        nread = this->protocol().available();
    }
    return nread;
}

///////////////////////////////ct.e////////////////////////////////////////
#undef prefix_


// Local Variables:
// mode: c++
// fill-column: 100
// c-file-style: "senf"
// indent-tabs-mode: nil
// ispell-local-dictionary: "american"
// End:
