// $Id$
//
// Copyright (C) 2006 
// Fraunhofer Institut fuer offene Kommunikationssysteme (FOKUS)
// Kompetenzzentrum fuer Satelitenkommunikation (SatCom)
//     Stefan Bund <stefan.bund@fokus.fraunhofer.de>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

/** \file
    \brief senf::ClientSocketHandle non-inline template implementation
 */

//#include "ClientSocketHandle.ih"

// Custom includes

#define prefix_
///////////////////////////////ct.p////////////////////////////////////////

template <class Policy>
prefix_ std::string senf::ClientSocketHandle<Policy>::read(unsigned limit)
{
    std::string rv;
    this->read(rv,limit);
    return rv;
}

template <class Policy>
prefix_ void senf::ClientSocketHandle<Policy>::read(std::string & buffer, unsigned limit)
{
    unsigned nread = available();
    if (limit>0 && nread>limit) 
	nread = limit;
    /** \fixme This is not necessary correct and more or less a hack ... */
    buffer.assign(nread,0);
    unsigned rv = this->read(const_cast<char *>(buffer.data()),nread);
    if (rv < nread)
        buffer.erase(buffer.begin()+rv,buffer.end());
}

template <class Policy>
prefix_ std::pair<std::string, typename Policy::AddressingPolicy::Address>
senf::ClientSocketHandle<Policy>::readfrom()
{
    std::string rv;
    typename Policy::AddressingPolicy::Address addr;
    this->readfrom(rv,addr);
    return std::make_pair(rv,addr);
}

template <class Policy>
prefix_ void senf::ClientSocketHandle<Policy>::
readfrom(std::string & buffer, typename Policy::AddressingPolicy::Address & from)
{
    unsigned nread = available();
    /** \fixme This is not necessary correct and more or less a hack ... */
    buffer.assign(nread,0);
    unsigned rv = this->readfrom(const_cast<char *>(buffer.data()), nread, from);
    if (rv < nread)
        buffer.erase(buffer.begin()+rv,buffer.end());
}

template <class Policy>
prefix_ unsigned senf::ClientSocketHandle<Policy>::write(std::string const & data)
{
    unsigned written = this->write(data.data(),data.size());
    if (written == 0)
        throw SystemException(EPIPE);
    // This implementation ensures, we only call blocking() when
    // necessary (since it incurs a system call overhead ...)
    if (written < data.size() && this->blocking())
        // We need to enforce in the WritePolicy implementation, that
        // DatagramFramingPolicy sockets will ALWAYS either write the
        // complete datagram or nothing at all
        while (written < data.size()) {
            unsigned n = this->write(data.data()+written,data.size()-written); 
            if (n == 0)
                throw SystemException(EPIPE);
            written += n;
        }
    return written;
}

template <class Policy>
prefix_ unsigned senf::ClientSocketHandle<Policy>::available()
{
    unsigned nread = this->protocol().available();
    if (nread == 0 && this->blocking()) {
	// We have to block explicitly here so we can return the
	// number of bytes available explicitly. If no more date can
	// be expected to arive (i.e. the other end has closed the
	// connection), the socket will always be in the readable
	// state. This is the only case when available() will return
	// 0.
	this->waitReadable();
	nread = this->protocol().available();
    }
    return nread;
}

///////////////////////////////ct.e////////////////////////////////////////
#undef prefix_


// Local Variables:
// mode: c++
// c-file-style: "senf"
// End:
