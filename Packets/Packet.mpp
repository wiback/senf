// $Id$
//
// Copyright (C) 2006 
// Fraunhofer Institut fuer offene Kommunikationssysteme (FOKUS)
// Kompetenzzentrum fuer Satelitenkommunikation (SatCom)
//     Stefan Bund <stefan.bund@fokus.fraunhofer.de>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

#if !BOOST_PP_IS_ITERATING

// Custom includes
#include <boost/preprocessor/iteration/iterate.hpp>
#include <boost/preprocessor/enum.hpp>
#include <boost/preprocessor/cat.hpp>

#  ifndef MPP_Packet_
#    define MPP_Packet_
#    define pkARG(z,n,data) BOOST_PP_CAT(A,n) const & BOOST_PP_CAT(a,n)
#  else
#    undef pkARG
#  endif

#else
//////////////////////////////mpp.p////////////////////////////////////////

#if BOOST_PP_ITERATION_DEPTH()==1 && BOOST_PP_ITERATION_FLAGS()==1
///////////////////////////////////////////////////////////////////////////
// Packet::reinterpret member template declaration

template < class OtherPacket, BOOST_PP_ENUM_PARAMS(BOOST_PP_ITERATION(), class A) >
typename ptr_t<OtherPacket>::ptr reinterpret( BOOST_PP_ENUM( BOOST_PP_ITERATION(), pkARG, ) );

#elif BOOST_PP_ITERATION_DEPTH()==1 && BOOST_PP_ITERATION_FLAGS()==2
///////////////////////////////////////////////////////////////////////////
// Packet::reinterpret implementation

template <class OtherPacket, BOOST_PP_ENUM_PARAMS(BOOST_PP_ITERATION(), class A) >
prefix_ typename senf::Packet::ptr_t<OtherPacket>::ptr
senf::Packet::reinterpret( BOOST_PP_ENUM( BOOST_PP_ITERATION(), pkARG, ) )
{
    if (!OtherPacket::check(begin(),end()))
        throw TruncatedPacketException();
    typename ptr_t<OtherPacket>::ptr p (
        new OtherPacket(PacketOp_replace(this),
			BOOST_PP_ENUM_PARAMS( BOOST_PP_ITERATION(), a ) ),
        false);
    return p;
}

#elif BOOST_PP_ITERATION_DEPTH()==1 && BOOST_PP_ITERATION_FLAGS()==3
///////////////////////////////////////////////////////////////////////////
// Packet::registerInterpreter member template declaration

template < class OtherPacket, BOOST_PP_ENUM_PARAMS(BOOST_PP_ITERATION(), class A) >
typename ptr_t<OtherPacket>::ptr registerInterpreter(
    raw_container::iterator begin, raw_container::iterator end,
    BOOST_PP_ENUM( BOOST_PP_ITERATION(), pkARG, ) ) const;

#elif BOOST_PP_ITERATION_DEPTH()==1 && BOOST_PP_ITERATION_FLAGS()==4
///////////////////////////////////////////////////////////////////////////
// Packet::registerIterpreter implementation

template <class OtherPacket, BOOST_PP_ENUM_PARAMS(BOOST_PP_ITERATION(), class A) >
prefix_ typename senf::Packet::ptr_t<OtherPacket>::ptr
senf::Packet::registerInterpreter(raw_container::iterator begin,
                                         raw_container::iterator end,
                                         BOOST_PP_ENUM( BOOST_PP_ITERATION(), pkARG, ) )
    const
{
    if (!OtherPacket::check(begin,end))
        throw TruncatedPacketException();
    typename ptr_t<OtherPacket>::ptr p (
	new OtherPacket(PacketOp_register(begin-impl_->data_.begin(),
					  end-impl_->data_.begin(),
					  this),
			BOOST_PP_ENUM_PARAMS( BOOST_PP_ITERATION(), a) ),
        false);
    return p;
}

#elif BOOST_PP_ITERATION_DEPTH()==1 && BOOST_PP_ITERATION_FLAGS()==5
///////////////////////////////////////////////////////////////////////////
// Packet::create declaration

template < class OtherPacket, class InputIterator, 
           BOOST_PP_ENUM_PARAMS(BOOST_PP_ITERATION(), class A) >
static typename senf::Packet::ptr_t<OtherPacket>::ptr create(
    InputIterator b, InputIterator e,
    BOOST_PP_ENUM( BOOST_PP_ITERATION(), pkARG, ) );

#elif BOOST_PP_ITERATION_DEPTH()==1 && BOOST_PP_ITERATION_FLAGS()==6
///////////////////////////////////////////////////////////////////////////
// Packet::create implementation

template < class OtherPacket, class InputIterator, 
           BOOST_PP_ENUM_PARAMS(BOOST_PP_ITERATION(), class A) >
typename senf::Packet::ptr_t<OtherPacket>::ptr senf::Packet::create(
    InputIterator b, InputIterator e,
    BOOST_PP_ENUM( BOOST_PP_ITERATION(), pkARG, ) )
{
    boost::intrusive_ptr<impl::PacketImpl> impl (new impl::PacketImpl(b,e),false);
    if (!OtherPacket::check(impl->data_.begin(), impl->data_.end()))
        throw TruncatedPacketException();
    typename ptr_t<OtherPacket>::ptr p (
	new OtherPacket(PacketOp_set(impl.get()),
			BOOST_PP_ENUM_PARAMS( BOOST_PP_ITERATION(), a) ),
        false);
    return p;
}

#endif

//////////////////////////////mpp.e////////////////////////////////////////
#endif


// Local Variables:
// mode: c++
// c-file-style: "senf"
// End:
