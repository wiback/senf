// $Id$
//
// Copyright (C) 2006 
// Fraunhofer Institut fuer offene Kommunikationssysteme (FOKUS)
// Kompetenzzentrum fuer Satelitenkommunikation (SatCom)
//     Stefan Bund <stefan.bund@fokus.fraunhofer.de>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Definition of non-inline template funPacketRegistry.ons

#include "PacketRegistry.ih"

// Custom includes
#include <iostream>
#include "Utils/TypeInfo.hh"

#define prefix_
///////////////////////////////ct.p////////////////////////////////////////

template <class KeyType>
template <class OtherPacket>
prefix_ void satcom::pkf::impl::PacketRegistryImpl<KeyType>::registerPacket(key_t key)
{
    // If this assertion fails, a Packet was registered with an already known key
    BOOST_ASSERT( registry_.insert(std::make_pair(
        key, Entry_ptr(new impl::PkReg_EntryImpl<OtherPacket>()))).second );
    // If this assertion fails, the same Packet was registered with two different keys
    BOOST_ASSERT( reverseRegistry_.insert(
        std::make_pair(satcom::lib::typeIdValue<OtherPacket>(), key)).second );
}

template <class KeyType>
prefix_ typename satcom::pkf::impl::PacketRegistryImpl<KeyType>::key_t
satcom::pkf::impl::PacketRegistryImpl<KeyType>::key(satcom::lib::TypeIdValue const & type)
{
    typename ReversePacketMap::iterator i (reverseRegistry_.find(type));
    if (i==reverseRegistry_.end())
        throw PacketTypeNotRegistered();
    return i->second;
}

template <class OtherPacket>
prefix_ void
satcom::pkf::impl::PkReg_EntryImpl<OtherPacket>::registerInterpreter(Packet const * p,
                                                                     Packet::iterator b,
                                                                     Packet::iterator e)
{
    p->template registerInterpreter<OtherPacket>(b,e);
}

template <class OtherPacket>
prefix_ satcom::pkf::Packet::ptr
satcom::pkf::impl::PkReg_EntryImpl<OtherPacket>::reinterpret(Packet * p)
{
    return p->template reinterpret<OtherPacket>();
}

template <class KeyType>
prefix_ typename satcom::pkf::impl::PacketRegistryImpl<KeyType>::Entry *
satcom::pkf::impl::PacketRegistryImpl<KeyType>::lookup(key_t key)
{
    typename PacketMap::iterator i (registry_.find(key));
    if (i==registry_.end())
        return &impl::pkreg_dataEntry;
    return i->second.get();
}

template <class Tag>
template <class InputIterator>
prefix_ satcom::pkf::Packet::ptr
satcom::pkf::PacketRegistry<Tag>::create(typename Tag::key_t key, InputIterator b,
                                         InputIterator e)
{
    Packet::ptr p (Packet::create<DataPacket>(b,e));
    return registry().lookup(key)->reinterpret(p.get());
}

template <class Tag>
prefix_ typename satcom::pkf::PacketRegistry<Tag>::Registry &
satcom::pkf::PacketRegistry<Tag>::registry()
{
    static Registry registry;
    return registry;
}

///////////////////////////////ct.e////////////////////////////////////////
#undef prefix_


// Local Variables:
// mode: c++
// c-file-style: "satcom"
// End:
