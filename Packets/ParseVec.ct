// $Id$
//
// Copyright (C) 2006
// Fraunhofer Institut fuer offene Kommunikationssysteme (FOKUS)
// Kompetenzzentrum fuer Satelitenkommunikation (SatCom)
//     Stefan Bund <stefan.bund@fokus.fraunhofer.de>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Definition of non-inline template funPacketRegistry.ons

//#include "ParseVec.ih"

// Custom includes

#define prefix_
///////////////////////////////ct.p////////////////////////////////////////

template <class Parser, class SizeParser, class Container>
template <class Value>
prefix_ void
senf::Parse_Vector_wrapper<Parser,SizeParser,Container>::insert(iterator pos,
                                                                       Value const & t)
{
    size_type ix(pos.raw()-container_.begin());
    shift(pos);
    Parser(container_.begin()+ix).value(t);
}

template <class Parser, class SizeParser, class Container>
template <class Value>
prefix_ void
senf::Parse_Vector_wrapper<Parser,SizeParser,Container>::insert(iterator pos,
                                                                       size_type n,
                                                                       Value const & t)
{
    size_type ix(pos.raw()-container_.begin());
    shift(pos,n);
    typename Container::iterator j (container_.begin()+ix);
    for (; n; --n, j+=Parser::bytes())
        Parser(j).value(t);
}

template <class Parser, class SizeParser, class Container>
template <class InputIterator>
prefix_ void
senf::Parse_Vector_wrapper<Parser,SizeParser,Container>::insert(iterator pos,
                                                                       InputIterator f,
                                                                       InputIterator l)
{
    /** \todo This might be horribly inefficient ... we need to
        specialize for random_access and forward iterators, where we
        can count the distance */

    size_type ix(pos.raw()-container_.begin());
    for (;f!=l;++f) {
        insert(container_.begin()+ix,*f);
        ix += Parser::bytes();
    }
}

///////////////////////////////ct.e////////////////////////////////////////
#undef prefix_


// Local Variables:
// mode: c++
// fill-column: 100
// c-file-style: "senf"
// indent-tabs-mode: nil
// ispell-local-dictionary: "american"
// End:
