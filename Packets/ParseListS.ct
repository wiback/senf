// $Id$
//
// Copyright (C) 2006
// Fraunhofer Institut fuer offene Kommunikationssysteme (FOKUS)
// Kompetenzzentrum fuer Satelitenkommunikation (SatCom)
//     Stefan Bund <stefan.bund@fokus.fraunhofer.de>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Definition of non-inline template functions

#include "ParseListS.ih"

// Custom includes
#include <algorithm>

#define prefix_
///////////////////////////////ct.p////////////////////////////////////////

template <class Parser, class Sentinel, class Iterator, class IPacket>
prefix_ unsigned senf::Parse_ListS<Parser,Sentinel,Iterator,IPacket>::bytes()
    const
{
    iterator i (begin());
    iterator e (end());
    size_type s (0);
    for (; i!=e; ++i)
        s += i->bytes();
    // The sentinel is not part of the range
    // but it's part of the list !!
    return s+i->bytes();
}

template <class Parser, class Sentinel, class Iterator, class IPacket>
prefix_ bool
senf::Parse_ListS<Parser,Sentinel,Iterator,IPacket>::check(Iterator const & e)
    const
{
    byte_iterator i (this->i());
    for (;;) {
        value_type v (i);
        if (!v.check(e)) return false;
        if (sentinel::check(v)) return true;
        size_type s (v.bytes());
        if (s==0) return false;
        i += s;
    }
}

template <class Parser, class Sentinel, class Iterator, class IPacket>
prefix_ void senf::Parse_ListS<Parser,Sentinel,Iterator,IPacket>::init()
    const
{
    iterator i (begin());
    iterator e (end());
    for (;i!=e; ++i)
        i->init();
    // The sentinel is not part of the range
    // but it's part of the list !!
    i->init();
}

///////////////////////////////////////////////////////////////////////////
// senf::Parse_ListS_wrapper<Parser,Sentinel,Container>

template <class Parser, class Sentinel, class Container>
template <class Value>
prefix_ void
senf::Parse_ListS_wrapper<Parser,Sentinel,Container>::insert(iterator pos,
                                                             Value const & t)
{
    size_type ix (pos.raw()-container_.begin());
    container_.insert(pos.raw(),t.bytes(),0);
    Parser(container_.begin()+ix).value(t);
}

template <class Parser, class Sentinel, class Container>
template <class Value>
prefix_ void
senf::Parse_ListS_wrapper<Parser,Sentinel,Container>::insert(iterator pos, size_type n,
                                                             Value const & t)
{
    size_type ix (pos.raw()-container_.begin());
    container_.insert(pos.raw(),n*t.bytes(),0);
    typename Container::iterator i (container_.begin()+ix);
    for (; n; ++i, --n)
        Parser(i).value(t);
}

template <class Parser, class Sentinel, class Container>
template <class InputIterator>
prefix_ void
senf::Parse_ListS_wrapper<Parser,Sentinel,Container>::insert(iterator pos,
                                                             InputIterator f,
                                                             InputIterator l)
{
    /** \todo Optimize this for random-access and multi-pass iterators */
    for (;f!=l;++f,++pos) insert(pos,*f);
}

///////////////////////////////ct.e////////////////////////////////////////
#undef prefix_


// Local Variables:
// mode: c++
// fill-column: 100
// c-file-style: "senf"
// indent-tabs-mode: nil
// ispell-local-dictionary: "american"
// End:
